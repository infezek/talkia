// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: community.sql

package repository

import (
	"context"
	"time"
)

const listBotsOfCategoryTrends = `-- name: ListBotsOfCategoryTrends :many
SELECT b.id, b.user_id, b.category_id, b.name, b.personality, b.description, b.avatar_url, b.background_url, b.location, b.published, b.active, b.created_at, b.updated_at, COUNT(ulb.id) AS likes
FROM bots b LEFT JOIN user_like_bot ulb ON b.id = ulb.bot_id
WHERE  ulb.created_at >= ? AND ulb.created_at <= ? AND b.category_id = ?
GROUP BY  b.id, b.name
ORDER BY  likes DESC LIMIT 10
`

type ListBotsOfCategoryTrendsParams struct {
	CreatedAt   time.Time
	CreatedAt_2 time.Time
	CategoryID  string
}

type ListBotsOfCategoryTrendsRow struct {
	ID            string
	UserID        string
	CategoryID    string
	Name          string
	Personality   string
	Description   string
	AvatarUrl     string
	BackgroundUrl string
	Location      string
	Published     bool
	Active        bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Likes         int64
}

func (q *Queries) ListBotsOfCategoryTrends(ctx context.Context, arg ListBotsOfCategoryTrendsParams) ([]ListBotsOfCategoryTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, listBotsOfCategoryTrends, arg.CreatedAt, arg.CreatedAt_2, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBotsOfCategoryTrendsRow
	for rows.Next() {
		var i ListBotsOfCategoryTrendsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Personality,
			&i.Description,
			&i.AvatarUrl,
			&i.BackgroundUrl,
			&i.Location,
			&i.Published,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesTrends = `-- name: ListCategoriesTrends :many
SELECT c.id, c.name, c.active, c.created_at, c.updated_at, SUM(sub.likes) AS total_likes
FROM categories AS c
LEFT JOIN (
    SELECT b.category_id, b.id AS bot_id, COUNT(ulb.id) AS likes
    FROM bots AS b
    LEFT JOIN user_like_bot AS ulb ON b.id = ulb.bot_id
    WHERE  ulb.created_at >= ? AND ulb.created_at <= ?
    GROUP BY b.category_id, b.id
) AS sub ON c.id = sub.category_id
GROUP BY c.id, c.name
ORDER BY c.name
`

type ListCategoriesTrendsParams struct {
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

type ListCategoriesTrendsRow struct {
	ID         string
	Name       string
	Active     bool
	CreatedAt  time.Time
	UpdatedAt  time.Time
	TotalLikes interface{}
}

func (q *Queries) ListCategoriesTrends(ctx context.Context, arg ListCategoriesTrendsParams) ([]ListCategoriesTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesTrends, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesTrendsRow
	for rows.Next() {
		var i ListCategoriesTrendsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalLikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrends = `-- name: ListTrends :many
SELECT b.id, b.user_id, b.category_id, b.name, b.personality, b.description, b.avatar_url, b.background_url, b.location, b.published, b.active, b.created_at, b.updated_at, COUNT(ulb.id) AS likes
FROM bots b LEFT JOIN user_like_bot ulb ON b.id = ulb.bot_id
WHERE  ulb.created_at >= ? AND ulb.created_at <= ?
GROUP BY  b.id, b.name
ORDER BY  likes DESC LIMIT 10
`

type ListTrendsParams struct {
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

type ListTrendsRow struct {
	ID            string
	UserID        string
	CategoryID    string
	Name          string
	Personality   string
	Description   string
	AvatarUrl     string
	BackgroundUrl string
	Location      string
	Published     bool
	Active        bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Likes         int64
}

func (q *Queries) ListTrends(ctx context.Context, arg ListTrendsParams) ([]ListTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrends, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTrendsRow
	for rows.Next() {
		var i ListTrendsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Personality,
			&i.Description,
			&i.AvatarUrl,
			&i.BackgroundUrl,
			&i.Location,
			&i.Published,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
