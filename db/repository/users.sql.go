// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const addCategoriesByUserID = `-- name: AddCategoriesByUserID :exec
INSERT INTO users_categories (id, user_id, category_id) VALUES (?, ?, ?)
`

type AddCategoriesByUserIDParams struct {
	ID         string
	UserID     string
	CategoryID string
}

func (q *Queries) AddCategoriesByUserID(ctx context.Context, arg AddCategoriesByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, addCategoriesByUserID, arg.ID, arg.UserID, arg.CategoryID)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users 
(id, username, email, password, platform, location, language, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
`

type CreateUserParams struct {
	ID       string
	Username string
	Email    string
	Password string
	Platform UsersPlatform
	Location string
	Language UsersLanguage
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Platform,
		arg.Location,
		arg.Language,
	)
	return err
}

const deleteCategoriesUserID = `-- name: DeleteCategoriesUserID :exec
DELETE FROM users_categories WHERE user_id = ?
`

func (q *Queries) DeleteCategoriesUserID(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteCategoriesUserID, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const findChatsByID = `-- name: FindChatsByID :many
SELECT id, user_id, bot_id FROM chats WHERE user_id = ?
`

type FindChatsByIDRow struct {
	ID     string
	UserID string
	BotID  string
}

func (q *Queries) FindChatsByID(ctx context.Context, userID string) ([]FindChatsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findChatsByID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindChatsByIDRow
	for rows.Next() {
		var i FindChatsByIDRow
		if err := rows.Scan(&i.ID, &i.UserID, &i.BotID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findChatsByUserID = `-- name: FindChatsByUserID :many
SELECT id, user_id, bot_id, created_at, updated_at FROM chats WHERE user_id = ?
`

func (q *Queries) FindChatsByUserID(ctx context.Context, userID string) ([]Chat, error) {
	rows, err := q.db.QueryContext(ctx, findChatsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BotID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLikeBotByBotID = `-- name: FindLikeBotByBotID :many
SELECT ulb.id, user_id, bot_id, ulb.created_at, ulb.updated_at, u.id, username, email, avatar_url, password, language, platform, gender, location, u.created_at, u.updated_at FROM user_like_bot ulb JOIN users u ON user_like_bot.user_id = users.id WHERE ulb.bot_id = ?
`

type FindLikeBotByBotIDRow struct {
	ID          string
	UserID      string
	BotID       string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	ID_2        string
	Username    string
	Email       string
	AvatarUrl   sql.NullString
	Password    string
	Language    UsersLanguage
	Platform    UsersPlatform
	Gender      NullUsersGender
	Location    string
	CreatedAt_2 time.Time
	UpdatedAt_2 time.Time
}

func (q *Queries) FindLikeBotByBotID(ctx context.Context, botID string) ([]FindLikeBotByBotIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findLikeBotByBotID, botID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLikeBotByBotIDRow
	for rows.Next() {
		var i FindLikeBotByBotIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BotID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.AvatarUrl,
			&i.Password,
			&i.Language,
			&i.Platform,
			&i.Gender,
			&i.Location,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLikeBotByUserAndBot = `-- name: FindLikeBotByUserAndBot :one
SELECT id, user_id, bot_id, created_at, updated_at FROM user_like_bot WHERE user_id = ? AND bot_id = ?
`

type FindLikeBotByUserAndBotParams struct {
	UserID string
	BotID  string
}

func (q *Queries) FindLikeBotByUserAndBot(ctx context.Context, arg FindLikeBotByUserAndBotParams) (UserLikeBot, error) {
	row := q.db.QueryRowContext(ctx, findLikeBotByUserAndBot, arg.UserID, arg.BotID)
	var i UserLikeBot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BotID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLikeBotByUserID = `-- name: FindLikeBotByUserID :many
SELECT ulb.id, ulb.user_id, bot_id, ulb.created_at, ulb.updated_at, b.id, b.user_id, category_id, name, personality, description, avatar_url, background_url, location, published, active, b.created_at, b.updated_at FROM user_like_bot ulb JOIN bots b ON user_like_bot.bot_id = bots.id WHERE ulb.user_id = ?
`

type FindLikeBotByUserIDRow struct {
	ID            string
	UserID        string
	BotID         string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          string
	UserID_2      string
	CategoryID    string
	Name          string
	Personality   string
	Description   string
	AvatarUrl     string
	BackgroundUrl string
	Location      string
	Published     bool
	Active        bool
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) FindLikeBotByUserID(ctx context.Context, userID string) ([]FindLikeBotByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findLikeBotByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLikeBotByUserIDRow
	for rows.Next() {
		var i FindLikeBotByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BotID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID_2,
			&i.CategoryID,
			&i.Name,
			&i.Personality,
			&i.Description,
			&i.AvatarUrl,
			&i.BackgroundUrl,
			&i.Location,
			&i.Published,
			&i.Active,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, username, email, avatar_url, password, language, platform, gender, location, created_at, updated_at FROM users WHERE email = ?
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AvatarUrl,
		&i.Password,
		&i.Language,
		&i.Platform,
		&i.Gender,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, avatar_url, password, language, platform, gender, location, created_at, updated_at FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AvatarUrl,
		&i.Password,
		&i.Language,
		&i.Platform,
		&i.Gender,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likeToBot = `-- name: LikeToBot :exec
INSERT INTO user_like_bot (id, user_id, bot_id, created_at) VALUES (?, ?, ?, NOW())
`

type LikeToBotParams struct {
	ID     string
	UserID string
	BotID  string
}

func (q *Queries) LikeToBot(ctx context.Context, arg LikeToBotParams) error {
	_, err := q.db.ExecContext(ctx, likeToBot, arg.ID, arg.UserID, arg.BotID)
	return err
}

const listBotsByUserID = `-- name: ListBotsByUserID :many
SELECT b.id, b.user_id, b.category_id, b.name, b.personality, b.description, b.avatar_url, b.background_url, b.location, b.published, b.active, b.created_at, b.updated_at,
       (SELECT COUNT(*) FROM user_like_bot WHERE bot_id = b.id) AS likes
FROM bots AS b
WHERE b.user_id = ?
ORDER BY b.created_at DESC
LIMIT ? OFFSET ?
`

type ListBotsByUserIDParams struct {
	UserID string
	Limit  int32
	Offset int32
}

type ListBotsByUserIDRow struct {
	ID            string
	UserID        string
	CategoryID    string
	Name          string
	Personality   string
	Description   string
	AvatarUrl     string
	BackgroundUrl string
	Location      string
	Published     bool
	Active        bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Likes         int64
}

func (q *Queries) ListBotsByUserID(ctx context.Context, arg ListBotsByUserIDParams) ([]ListBotsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listBotsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBotsByUserIDRow
	for rows.Next() {
		var i ListBotsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Personality,
			&i.Description,
			&i.AvatarUrl,
			&i.BackgroundUrl,
			&i.Location,
			&i.Published,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBotsByUserIDCount = `-- name: ListBotsByUserIDCount :one
SELECT count(*) FROM bots WHERE user_id = ?
`

func (q *Queries) ListBotsByUserIDCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, listBotsByUserIDCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listCategoriesByUserID = `-- name: ListCategoriesByUserID :many
SELECT c.id, c.name, c.active, c.created_at, c.updated_at FROM users_categories uc JOIN categories c ON uc.category_id = c.id WHERE uc.user_id = ?
`

func (q *Queries) ListCategoriesByUserID(ctx context.Context, userID string) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishBot = `-- name: PublishBot :exec
UPDATE bots SET published = TRUE WHERE id = ? AND user_id = ?
`

type PublishBotParams struct {
	ID     string
	UserID string
}

func (q *Queries) PublishBot(ctx context.Context, arg PublishBotParams) error {
	_, err := q.db.ExecContext(ctx, publishBot, arg.ID, arg.UserID)
	return err
}

const updateAvatarURL = `-- name: UpdateAvatarURL :exec
UPDATE users SET avatar_url = ? WHERE id = ?
`

type UpdateAvatarURLParams struct {
	AvatarUrl sql.NullString
	ID        string
}

func (q *Queries) UpdateAvatarURL(ctx context.Context, arg UpdateAvatarURLParams) error {
	_, err := q.db.ExecContext(ctx, updateAvatarURL, arg.AvatarUrl, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET 
username = ?,
language = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Username string
	Language UsersLanguage
	ID       string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Username, arg.Language, arg.ID)
	return err
}
